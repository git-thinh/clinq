[
  {
    "Id": "235390",
    "ThreadId": "69182",
    "Html": "<p>First off, I mostly want to say thank you for the library!! You have no idea how much time/complexity you have saved me.</p>\r\n<p>Being said, in my travels I've run across a few issues and just wanted to let you know about them in case you hadn't noticed. If my solutions seem retarted, please excuse them since I'm a VB coder and this was the first time I've ever had to go through a c# library.</p>\r\n<p>First, my collections are usually instantiated on a non UI thread. The cross-thread events didnt cause a problem with most controls but I did have exceptions with the combobox. I needed a way to set my own dispatcher so I added a property to ContinuousCollection that allowed me to set the UI Thread's Dispatcher.</p>\r\n<p>The second problem also has to do with comboboxes when properties change or items are added/removed from a SortingReadonlyContinuousCollection. If the item was selected at the time of the change, the RemoveItemFromOutput() function would cause the selection to be reset to nothing. This solution was a little trickier (at least for someone who has never coded in c#). I overloaded InsertItemInSortOrder and RemoveItemFromOutput with a boolean that would suppress the FireCollectionChanged call within them.OnItemChanged() now becomes:</p>\r\n<p>&nbsp;</p>\r\n<div style=\"color:Black;background-color:White\">\r\n<pre><span style=\"color:Blue\">void</span> OnItemChanged(INotifyPropertyChanged sender, String PropName)\r\n        {\r\n            TSource item = (TSource)sender;\r\n            <span style=\"color:Blue\">int</span> RemoveFrom = RemoveItemFromOutput(item, <span style=\"color:Blue\">true</span>);\r\n            <span style=\"color:Blue\">int</span> InsertTo = InsertItemInSortOrder(item, <span style=\"color:Blue\">true</span>);\r\n            <span style=\"color:Blue\">if</span> (RemoveFrom != InsertTo) { FireCollectionChanged(<span style=\"color:Blue\">new</span> NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction.Reset));}\r\n            <span style=\"color:Blue\">this</span>.OnPropertyChanged(PropName);\r\n        }\r\n</pre>\r\n</div>\r\n<p>&nbsp;</p>\r\n<p>Changing the way events are called fixed the problem of having the combobox's selected item from being reset. But then I noticed that the DisplayMember of the property was not updating because the OnPropertyChanged event was never getting called/making it to the control. Thats where the additional parameter PropName comes in. I added ChangedPropName to the SubscriptionTree object, then updated the ItemChanged event in NotifyCollectionChangedMonitor to pass the property name in addition to the sender.</p>\r\n<p>&nbsp;</p>\r\n<p>between those two changes, the combobox now seems to be acting as it should. If you think my changes may have broken some other functionality, please let me know.</p>\r\n<p>&nbsp;</p>\r\n<p>Btw, thanks again for putting this project together.</p>\r\n<p>&nbsp;</p>",
    "PostedDate": "2009-09-16T18:02:11.667-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]