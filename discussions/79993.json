[
  {
    "Id": "274050",
    "ThreadId": "79993",
    "Html": "<p>I was so excited to use SelectMany, then the dreaded &quot;This type of CollectionView does not support changes to its SourceCollection from a thread different from the Dispatcher thread.&quot; descended. &nbsp;I tried to modify FireCollectionChanged to iterate over the CollectionChanged invocation list and invoke handling on their own thread, but that just led to other issues.</p>\r\n<p>Obviously, I could look into removing all threading from my application, but I don't think that's feasible at this time. &nbsp;Have you given any thought to this problem, is there a solution for me?</p>\r\n<p>Thanks.</p>",
    "PostedDate": "2010-01-06T15:52:15.893-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "413221",
    "ThreadId": "79993",
    "Html": "<p>I am seeing this very same issue.&nbsp;The problem is when you bind a collection to an ItemsControl in WPF, it generates an ICollectionView instance for it.&nbsp; The views are a UI concept and, as such, have a connection to the owner UI thread. Thus, if you try to modify the collection view from a non-UI thread, you'll see this type of exception. The problem lies in the fact that although ContinuousCollection&lt;T&gt; knows about the Dispatcher and is able to behave correctly when called from any thread, ReadOnlyContinuousCollection&lt;T&gt; is <em>not</em> aware of the Dispatcher and thus executes all notifications on the calling thread.</p>\r\n<p>The fix that&nbsp;has worked&nbsp;for me was to modify the ReadOnlyContinuousCollection&lt;T&gt; class as follows:&nbsp;</p>\r\n<ol>\r\n<li>Add a field:<br>\r\n<div style=\"color:Black;background-color:White\">\r\n<pre><span style=\"color:Blue\">private</span> <span style=\"color:Blue\">readonly</span> Dispatcher dispatcher;\r\n</pre>\r\n</div>\r\n</li>\r\n<li>Create a default constructor:<br>\r\n<div style=\"color:Black;background-color:White\">\r\n<pre><span style=\"color:Blue\">protected</span> ReadOnlyContinuousCollection()\r\n{\r\n    dispatcher = Dispatcher.CurrentDispatcher;\r\n}\r\n</pre>\r\n</div>\r\n</li>\r\n<li>Modify FireCollectionChanged to execute on the dispatcher. <br>\r\n<div style=\"color:Black;background-color:White\">\r\n<pre>Action action = () =&gt;\r\n                    {\r\n                        <span style=\"color:Blue\">if</span> (CollectionChanged != <span style=\"color:Blue\">null</span>)\r\n                        {\r\n                            CollectionChanged(<span style=\"color:Blue\">this</span>, args);\r\n                        }\r\n\r\n                        <span style=\"color:Blue\">if</span> (args.Action != NotifyCollectionChangedAction.Replace)\r\n                        {\r\n                            OnPropertyChanged(<span style=\"color:#A31515\">&quot;Count&quot;</span>);\r\n                        }\r\n                    };\r\n         \r\ndispatcher.BeginInvoke(DispatcherPriority.Normal, action);</pre>\r\n</div>\r\n</li>\r\n</ol>\r\n<p>Hope this helps temporarily, but I am hoping for a solution from the CLinq guys for this as well.</p>\r\n<p>- Szymon</p>",
    "PostedDate": "2010-03-02T08:06:16.6-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "413364",
    "ThreadId": "79993",
    "Html": "<p>One note: the solution above will help with the immediate problem you are seeing.</p>\r\n<p>The fact, however, is that CLinq may not be thread safe in other ways. One problem we've ran into is that if:</p>\r\n<ol>\r\n<li>We have a ContinuousCollection&lt;DataObject&gt;</li>\r\n<li>We have a set of Continuous aggregations and queries on top of that collection </li>\r\n<li>DataObject implements INotifyPropertyChanged</li>\r\n</ol>\r\n<p>We updated the properties of our set of DataObjects from different threads simultaneously and&nbsp;we quickly ran into exceptions being thrown internally in the CLinq code in which collection views were unable to find items at specified positions and other exceptions. Getting rid of multi-threaded data object updates got rid of these.</p>\r\n<p>I'd wait for a thread-safe release before going with full on multi threaded CRUD operations on the collection and data objects.</p>\r\n<p>-Szymon</p>",
    "PostedDate": "2010-03-02T13:32:32.76-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "413823",
    "ThreadId": "79993",
    "Html": "<p>Hi all,</p>\r\n<p>As always, I take too long to reply to these threads.&nbsp; The multithreading problem is a hard one for this library.&nbsp; The reason being is that notification and access are not atomic unless you do Invokes rather than BeginInvokes.&nbsp; This means that by the time the handler is able to read the data, the data may have changed again or if the clause of a query accesses the data multiple times then things could change between accesses.&nbsp; Imagine if you have a Where(obj =&gt; obj.Friend != null &amp;&amp; obj.Friend.Name == &quot;Foo&quot;).&nbsp; If there is a context switch after the null check and someone sets the Friend property to null, then a null reference exception will be thrown. In my experience the best way to handle cross thread communication is via message passing or ownership passing.&nbsp; Attempting to put in a locking mechanism for this would probably not work out either.&nbsp;</p>\r\n<p>The best way to deal with this problem right now is to make your queries &quot;live&quot; on a single thread and marshal things to that thread.&nbsp; I could, write something that will be a cross thread collection change bridge so that you can define a query on a background thread:</p>\r\n<p>ReadOnlyObservableCollection&lt;Person&gt; ninjas = peopleCollection.Where( person =&gt; person.Title = &quot;Ninja&quot; );</p>\r\n<p>Then, you would define a collection that you could then data bind to, or safely access from a different thread.&nbsp; (Let's just say this is the UI thread for argument's sake.)</p>\r\n<p>ReadOnlyObservableCollection&lt;Person&gt; ninjasForThisThread = ninjas.MarshallToThisThread();</p>\r\n<p>Under the covers, each thread would store it's own copy of the data.&nbsp; The query logic would only run on the background thread, and as things are added or removed from the collection on the background thread, they are then marshalled to the UI thread.&nbsp; To the UI thread it would appear exactly the same.&nbsp;</p>\r\n<p>Now... the only catch is that items in the collection that is on the background thread still cannot be modified on any other thread.&nbsp; For example, if you have two worker threads: thread A, and thread B, and you defined ninja query on thread A, you still cannot update a person in the peopleCollection on Thread B without bad things happening.&nbsp; The reason being is laid out above.</p>\r\n<p>What do you guys think?&nbsp; Coding the marshaller up shouldn't be too painful, but if the above solution won't help, let me know.&nbsp;</p>\r\n<p>I am porting to Silverlight right now which is now going to be a new set of challenges as there is only one dispatcher in the whole system, and apps can't create Dispatchers for worker threads.</p>\r\n<p>&nbsp;</p>\r\n<p>Another thing to consider for the property change marshalling.&nbsp; (does not affect collection change really)</p>\r\n<p>Let's say you update 3000 objects that are being monitored by a query.&nbsp; If you put some kind of IsInvokeRequired in your OnPropertyChanged then you're in for 3000 dispatches across threads.&nbsp; So how do you batch these up?&nbsp; INotifyPropertyChanged uses C# eventing system so I would need people to put some kind of &quot;QueuePropertyChanged&quot; into their property setters which I think sucks.&nbsp; On the other hand... ContinuousCollection has AddRange and RemoveRange which does do batching, but that only helps for collection changes.</p>\r\n<p>Before I go further... can anyone tell me what perf bottlenecks they've hit with CLINQ that has pushed these types of operations to a background thread?&nbsp; The reason I ask, is that the main app at my company that puts CLINQ through it's paces uses thousands of objects with hundreds of live queries that all live on the UI thread.&nbsp; If you guys are exercising the system in a different way, perhaps I can change CLINQ to accommodate with</p>\r\n<p>Thanks,</p>\r\n<p>AK (your humble CLINQ narrator)</p>\r\n<p>&nbsp;</p>",
    "PostedDate": "2010-03-03T12:28:04.007-08:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  },
  {
    "Id": "441122",
    "ThreadId": "79993",
    "Html": "<p>Hei, nice tool!</p>\r\n<p>Not necessary on the same thread topic but I belive it kind of overlaps...</p>\r\n<p>My suggestion would be the following:</p>\r\n<p>- Add another constructor to&nbsp; the ContinousCollection Class that accepts a Dispatcher. Int his way your ContinousCollection becomes more flexible.</p>\r\n<p>For argument sake, lets assume I have a DataStore which is in fact a singleton - thus not using the UI thread - and I setup several properties whcih are ContinuousColelction of type XZY and background threads are responsible to update it, having the ViewModels consume these collections...If I can inject the UIThread then it makes &quot;life&quot; easier as I no longer use the current thread but force it to usee the UI Thread - but still capable of using the default parameterless constructor.</p>\r\n<p>I understand that there is a cost for this, but then again the collection already performs thread switching so I do not see any changes on that end.</p>\r\n<p>Food for thought I guess...</p>\r\n<p>&nbsp;</p>\r\n<p>&nbsp;</p>\r\n<p>&nbsp;</p>\r\n<p>&nbsp;</p>",
    "PostedDate": "2010-05-10T08:57:08.01-07:00",
    "UserRole": null,
    "MarkedAsAnswerDate": null
  }
]